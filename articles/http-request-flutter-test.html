<html><head><meta http-equiv="content-type" content="text/html;charset=utf-8"/><title>Making HTTP Requests in Flutter Tests | Timm Preetz</title><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"/><style></style><link rel="stylesheet" href="/assets/highlightjs.css"/></head><body><div id="navWrapper"><nav><a href="/" style="margin-right:20px;display:flex"><img src="/assets/ava.jpg" width="30" height="30" style="margin-top:5px;float:left;border-radius:2px"/><div class="name">Timm Preetz</div></a><div><a href="/projects">Projects</a>      <a href="/archive">Archive</a>      <a href="/about">About</a></div></nav></div><div id="mainWrapper" class="grt"><div class="contentWrapper"><div><h1>Making HTTP Requests in Flutter Tests</h1>
<p>By default all HTTP request made in a test invoked with <code>flutter test</code> <a href="https://github.com/flutter/flutter/blob/63aa5b3647dbd912a02f7545fc0101003cb3adc4/packages/flutter_test/lib/src/binding.dart#L1570">result in an empty response with status code 400</a>.</p>
<p>Generally that seems like a good default behavior to avoid external dependencies and hence reduce flakyness in tests. But what if you really want to make HTTP requests in your tests?</p>
<div class="note">HTTP requests are disabled for a good reason. Before enabling them, think abhout whether you have an even better reason to do so.</div>
<p>Since making outgoing requests in tests is discouraged, the usual advice is to use a mock client (for example <a href="https://pub.dartlang.org/documentation/http/latest/testing/MockClient-class.html"><code>MockClient</code></a> from the <code>http</code> package).</p>
<p>But how does one then efficiently and correctly create mock responses and assertions for incoming requests? For that we've written a request/response recording HTTP client.</p>
<p>Tests get run once with recording enabled, which writes the requests and responses as JSON files to disk. On subsequent runs the recording can then be disabled and all requests will be served form those files.</p>
<p>So that's why we needed to enable HTTP requests during tests in this specific case. How does one go about enabling them?</p>
<p>Turns out there is a discussion about this exact behavior on <a href="https://github.com/flutter/flutter/issues/19588#issuecomment-406771070">Flutter's GitHub Issues</a> which I was lucky to find after some searching. The simplified version of that solution, shown here as part of a test, is this:</p>
<pre><code class="language-dart">import 'dart:io';
import 'package:http/http.dart' as http;
// [...] other testing imports

Future&lt;void&gt; main() async {
  HttpOverrides.global = _MyHttpOverrides(); // Setting a customer override that'll use an unmocked HTTP client

  testWidgets(
    'Test with HTTP enabled',
    (tester) async {
      await tester.runAsync(() async { // Use `runAsync` to make real asynchronous calls
        expect(
          (await http.Client().get('https://www.google.com/')).statusCode,
          200,
        );
      });
    },
  );
}

class _MyHttpOverrides extends HttpOverrides {}
</code></pre>
</div></div></div></body></html>