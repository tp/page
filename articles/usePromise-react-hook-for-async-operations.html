<html><head><meta http-equiv="content-type" content="text/html;charset=utf-8"/><title>`usePromise`: A React hook for async data loading with server-side rendering (SSR) support | Timm Preetz</title><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover"/><link rel="stylesheet" href="/assets/highlightjs.css"/><link rel="alternate" type="application/rss+xml" title="Timm Preetz&#x27;s blog" href="/rss.xml"/><link rel="apple-touch-icon" sizes="180x180" href="/assets/favicon/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicon/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicon/favicon-16x16.png"/><link rel="manifest" href="/assets/favicon/site.webmanifest"/></head><body><div id="navWrapper"><nav><a href="/"><img src="/assets/ava.jpg" width="30" height="30" class="headerImage"/><div class="name">Timm Preetz</div></a><div><a href="/projects">Projects</a><a href="/archive">Archive</a><a href="/about">About</a></div></nav></div><div id="mainWrapper" class="grt"><div class="contentWrapper"><div><h1><code>usePromise</code>: A React hook for async data loading with server-side rendering (SSR) support</h1>
<div class="note"><b>Out now:</b> This post explores the background behind a new library, usePromise, that is now <a href="https://www.npmjs.com/package/@timm/use-promise">available on NPM</a>. The source code and examples are available on <a href="https://github.com/tp/use-promise">GitHub at tp/use-promise</a>.</div>
<p>React hooks can help build components made up of re-usable smaller helpers while still staying readable and clear even when a bunch of features are combined. This is a nice contrast to the previous lifecycle methods across in which multiple ‚Äúextensions‚Äù wheren‚Äôt always clearly visible - might it be because they only appeared in some methods, or because they appeared in a different order in each one and hence weren‚Äôt as easily scannable.</p>
<p>So when looking at a component design that would allow for 100% custom components to be injected into an app skeleton, fetching data via hooks seemed like a great solution. In contrast to render props and similar approaches, it doesn‚Äôt limit the consumer to what is provided by the outside helper in one pattern, and then force one to use a possibly different approach to load further data. (Or use nested render props components, which IMHO don‚Äôt read that well and still require manual passing of the props.)</p>
<p>So I was a little surprised to find out that as of now (React 16.8) one couldn‚Äôt easily compose a new hook for async data loading (with SSR support) for 2 reasons:</p>
<ol>
<li>State managed using the <code>setState</code> hook couldn‚Äôt be read out and be transferred to the client</li>
<li>Loading data asynchronously, and hence calling <code>setState</code> after the initial render on the server, doesn‚Äôt work with the current default model, which only renders once.</li>
</ol>
<p>Point #2 seems like a reasonable general limitation, because when you trigger the data loading in the component to be rendered, one for sure needs to attempt to render that component again after the data has been loaded. Rendering <code>n + 1</code> times (<em>n</em> for each data loading operation and then once for the final render to find out that there is nothing new to fetch) is an overhead not to take lightly, but <a href="https://reactjs.org/blog/2019/08/08/react-v16.9.0.html#an-update-to-the-roadmap">luckily React is working on a remedy to make this more lightweight with <code>Suspense</code> in the future</a>.</p>
<p>So while waiting on React to support #2 by default and at the same time adding a solution for #1 for the specific context of data-loading which does not require learning and setting up any state-management solution, I looked into building a small hook that would accomplish this.</p>
<p>The challenge, as mentioned before, is that any component in the tree could trigger a data-fetching operation, and then rendering would need to halt until that <code>Promise</code> is resolved. In lieu of <code>Suspense</code> the best I could come up with was to use the approach of rendering the whole tree again (something I also observed Apollo do) after each individual data loading operation has completed. Taking another page from the current <code>Suspense</code> playbook, whenever a component wants to load data via this new hook, it <code>throw</code>s that <code>Promise</code>, which the library then <code>await</code>s before attempting to render again. Once a render completed without any new <code>Promise</code> being scheduled (<code>throw</code>n), that rendering is taken as the final result and sent to the client.</p>
<p>In standard hooks fashion the library builds up an array holding the data of the single ongoing and potentially many completed <code>Promise</code>s. This data is then distributed on each rendering attempt to the hooks in order. Since this is only needed on the server (in an unchanging render tree) and then once for rehydration on the client, there is no issue with using this one global array (scoped to the current request) for the whole page (instead of a per component array which React itself uses).</p>
<p>The final data of all Promises is then serialized into the HTML send to the client, where it‚Äôs used for the initial rehydration, after which it switches to rely on React‚Äôs <code>setState</code> for managing further mutations.</p>
<p>In then end the usage looks like this:</p>
<pre><code class="language-ts"><span class="token keyword">function</span> <span class="token function">WhatToWear</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token punctuation">{</span>loading<span class="token punctuation">,</span> error<span class="token punctuation">,</span> data<span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">usePromise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> weatherApi<span class="token punctuation">.</span><span class="token function">getCurrentWeatherAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>loading<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token operator">&lt;</span>div<span class="token operator">></span>Loading‚Ä¶<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>
    <span class="token punctuation">}</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token operator">&lt;</span>div<span class="token operator">></span>An error occured‚Ä¶<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">return</span> <span class="token operator">&lt;</span>div<span class="token operator">></span>Recommended outfit<span class="token punctuation">:</span> <span class="token punctuation">{</span>weather<span class="token punctuation">.</span>temp <span class="token operator">></span> <span class="token number">19</span> <span class="token operator">?</span> <span class="token string">'üëö'</span> <span class="token punctuation">:</span> <span class="token string">'üß•'</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token punctuation">;</span>    
<span class="token punctuation">}</span>
</code></pre>
<p>The plan is now to take the <code>usePromise</code> helper and build up hooks for the specific domain, so the consumer wouldn‚Äôt have to deal with providing the <code>Promise</code> creating function herself.</p>
<p>In the end the resulting API is really small, just one line to pull in a some fully typed data and have the library taking care of data loading on the server. Additionally the consumer now has to take care of rendering the <code>loading</code> and <code>error</code> cases, but that would be something they will have to deal with in any case, unless they‚Äôre fine with rendering some default message, which could easily be achieved with a helper component.</p>
<p>Overall I am quite happy how this turned out on the usage side, even though the implementation has some rough edges and overhead at the moment. Possibly the overhead can be reduced in the future with <code>Suspense</code> ‚Äì if this library will not be made obsolete outright by it. In either case, the transition to some future React version should be smooth, very likely allowing us to keep the same outside API.</p>
<p>For now this is exactly what was needed and building up on so much great technology and inspiration I was happy to see how it could be achieved in a short amount of time.</p>
<h2>Thoughts on API design</h2>
<p>Initially the library followed the <code>useState</code> approach and returned an array of type <code>[boolean, T, unknown]</code>, which could be used for example as <code>[completed, weather, error]</code> (in the example case of fetching the current weather). The interesting bit here is how the array model doesn‚Äôt even suggest default names, and the user is forced to pick some for his use-case. But just having the types might be confusing in 2 cases: When not using / seeing the types immediately in the editor, or when the return type is <code>boolean</code> or anything unspecific like the <code>unkown</code> error type. In those cases it might not be obvious at which index the result is stored, especially if the library is not very familiar to the user (unlike <code>setState</code> which one probably interacts with daily in a hooks-using codebase).</p>
<p>The array approach was then debated, and since the primary use case was data loading, the API was changed to match Apollo‚Äôs <code>useQuery</code> (<a href="https://github.com/tp/use-promise/blob/b0dab8d5dfce28d45a6667a180e15f0fa92c1d7b/src/index.ts#L4">the actual types are more specific</a> than the example below):</p>
<pre><code class="language-ts"><span class="token punctuation">{</span>
    loading<span class="token punctuation">:</span> <span class="token builtin">boolean</span><span class="token punctuation">;</span>
    data<span class="token punctuation">:</span> <span class="token constant">T</span><span class="token punctuation">;</span>
    error<span class="token punctuation">:</span> Error<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>As you can see, it‚Äôs now an object which provides explicit names for each field. <code>completed</code> flipped to <code>loading</code>, which makes writing early returns much nicer. <code>error</code> is now limited to <code>Error</code>, but that might just be a temporary solution. What I wanted to achieve there was that <code>error</code> could be checked with a simple <code>if</code>, and if it was falsy the <code>Promise</code> would have resolved successfully and <code>data</code> would contain the result.</p>
<p>Remapping the names to something specific is still easily possibly.</p>
<p>One further consideration was how use the hook multiple times in a row. Then having multiple <code>loading</code> and <code>error</code> states might get very cumbersome, especially since you musn‚Äôt return early for any <code>Promise</code> rejection.</p>
<p>In the end the current design and documentation hopefully leads people to write a single helper function loading all relevant data for a component. This is a lot more efficient with the current implmentation detailed above, as well as making the component clearer as it has less states to think about.</p>
<p>If you have any feedback on the API design, for example feeling it‚Äôs now to focused on data loading, or any other suggestions <a href="https://github.com/tp/use-promise/issues">feel free to open a ticket with your feedback</a>.</p>
<h2>Closing Thoughts</h2>
<p>One thought that always pops up in my head when working on components which trigger or manage their own data loading ‚Äì especially whenn this done across multiple layers of components ‚Äì is whether it‚Äôs desirable and should be done that way at all.</p>
<p>I think it‚Äôs always worth to imagine what the alternative design of having a storage &amp; side-effect solution outside of the component tree would look like and what benefits one might gain from it. Compared to the above example, one clear benefit would be that one could do the data loading first, and then be done after a single render. On the other hand that forces one to combine all data-fetching logic into a single step on this ‚Äúother side‚Äù ‚Äì which might or might not be a good thing.</p>
<p>In the end this boils down to picking what‚Äôs right for the problem at hand. In the above case the goal was to make it easy to insert 1 or 2 data loading hooks across a page, and for that it seems far more approachable than learning any specific store system and hooking into it.</p>
<div class="alert">üë®üèº‚ÄçüíªIf you strive to make life developing web applications easier and enjoy exploring beyond the known solutions <a href="https://corporate.aboutyou.de/de/jobs/senior-frontend-developer">this might job might fancy your interest</a>.</div></div></div></div></body></html>