<html><head><meta http-equiv="content-type" content="text/html;charset=utf-8"/><title>Storing binary data in Flutter | Timm Preetz</title><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover"/><link rel="stylesheet" href="/assets/highlightjs.css"/><link rel="alternate" type="application/rss+xml" title="Timm Preetz&#x27;s blog" href="/rss.xml"/><link rel="apple-touch-icon" sizes="180x180" href="/assets/favicon/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicon/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicon/favicon-16x16.png"/><link rel="manifest" href="/assets/favicon/site.webmanifest"/></head><body><div id="navWrapper"><nav><a href="/"><img src="/assets/timm_head_ava.jpg" width="30" height="30" class="headerImage"/><div class="name">Timm Preetz</div></a><div><a href="/projects">Projects</a><a href="/archive">Archive</a><a href="/about">About</a></div></nav></div><div id="mainWrapper" class="grt"><div class="contentWrapper"><div><h1>Storing binary data in Flutter</h1>
<p>Data storage in a Flutter app initially usually focuses on storing some domain objects (e.g. chat messages), whereas binary data (files) are often either loaded on demand (e.g. attachment downloads) or cached transiently with something like <a href="https://pub.dev/packages/cached_network_image"><code>cached_network_image</code></a> (e.g. for profile images).</p>
<p>But what is to be done when one needs to permanently store files with the app, either as a local cache to reduce network usage across app runs, or to support offline functionality?</p>
<p>Let’s look it this from the perspective of persisting profile images, as these would generally be small enough to allow this thought experiment and to not force us into any specific storage medium by default.</p>
<h2>Local files with pointers from the entities</h2>
<p>Imagine a user class like <code>typedef User = ({int userId, String name, String? profileImagePath })</code>. The <code>profileImagePath</code> can be used to refer to a file on disk. This is easy enough to start with and populate initially, it would just be important to remove this file every time the that specific <code>User</code> object is either removed or updated to point to a new profile image path.<br>
Because when looking into the “file folders” afterwards (in some clean up operation), it’s probably not easy to identify which files are actively in use, and which are not and thus could be removed.</p>
<h2>Storing files separately in the database</h2>
<p>If we just need to store some files by known keys (e.g. <code>profile_image_123</code>), we could set up an <a href="https://pub.dev/documentation/indexed_entity_store/2.0.0-dev2/indexed_entity_store/IndexedEntityStore-class.html"><code>IndexedEntityStore</code></a> like this that stores the image like this:</p>
<pre><code class="language-dart"><span class="token keyword">typedef</span> ProfileImage <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">{</span>int userId<span class="token punctuation">,</span> Uint8List data<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/// Stores the profile images by user ID, </span>
<span class="token keyword">final</span> profileImageConnector <span class="token operator">=</span> IndexedEntityConnector<span class="token operator">&lt;</span>ProfileImage<span class="token punctuation">,</span> int<span class="token punctuation">,</span> Uint8List<span class="token operator">></span><span class="token punctuation">(</span>
  entityKey<span class="token punctuation">:</span> <span class="token string">'profile_images'</span><span class="token punctuation">,</span>
  getPrimaryKey<span class="token punctuation">:</span> <span class="token punctuation">(</span>t<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> t<span class="token punctuation">.</span>userId<span class="token punctuation">,</span>
  getIndices<span class="token punctuation">:</span> <span class="token punctuation">(</span>index<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  serialize<span class="token punctuation">:</span> <span class="token punctuation">(</span>t<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> t<span class="token punctuation">.</span>data<span class="token punctuation">,</span>
  deserialize<span class="token punctuation">:</span> <span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">(</span>userId<span class="token punctuation">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> data<span class="token punctuation">:</span> s<span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>The problem with this approach is approach is similar to the file storage above. While we can easy check whether we have a specific profile image stored for a user and then retrieve it, we can not (with the current library methods) get a list of all the profile images with their user IDs as the key is only used for storage but then not returned in <code>deserialize</code> or available to be queried (e.g. there is no <code>getAllKeys</code>).<br>
This minor limitations could of course alleviated in the store’s API (though it’s questionable whether this would be a broadly useful extension of it), but when we work with what is available right now, we would still have to manually clean up each profile image when the user is deleted.</p>
<p>In a purpose-built SQLite-based storage for this use-case, one could of course have a foreign key from the profile images to the user, to ensure that they are removed in unison – or just make the profile image a column in the user table.</p>
<h2>Storing the file with the entities</h2>
<p>Another approach would be to store the file alongside the entity in whatever object storage the app uses. This introduces some obvious limitations, like the maximum file size (which is probably fine for a profile picture, not so much for a home video), and the amount of files any entity could refer to (is it 1 or 2, or <code>n</code>?).</p>
<p>It would probably not be advisable to put the profile image directly on the <code>User</code> object using any approach (like <code>typedef User = ({int userId, String name, Uint8List? profileImage })</code>), as that would leave no way to pass around the <code>User</code> without the image data.
Also when serializing this, one would have to handle the primitive data and the user image separately, as the usual <code>toJSON</code> would not be satifactory by default.</p>
<h2>Storing files with metadata</h2>
<p>So, if one still wants to store the files in the database, but not directly with the containing entity (such that also one-to-many relationship would also be possible without building bigger and bigger BLOBs), one might choose to save the file plus some metadata as its own entity.</p>
<p>The constraint of our choosen storage solution is though, that we only get one database field to write everything into. Thus we have to implement a storage format that can handle both the metadata and the binary data. In this case we’ll assume that the metadata is much smaller than the actual data, and will prepend the metadata (as JSON in this case) in front of the <code>Uint8List</code> binary data.</p>
<p>The storage inside the database would look like this:</p>
<pre><code>-------------------------------------------------------------
| Metadata length | Metadata JSON |       Binary data       |
-------------------------------------------------------------
     4 bytes        $length bytes           * bytes
</code></pre>
<p>The implementation of that storage approach might looks like this:</p>
<pre><code class="language-dart"><span class="token keyword">typedef</span> ImageWithMetadata <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">{</span>ImageMetadata metadata<span class="token punctuation">,</span> Uint8List data<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">final</span> imageWithMetadataConnector <span class="token operator">=</span>
    IndexedEntityConnector<span class="token operator">&lt;</span>ImageWithMetadata<span class="token punctuation">,</span> int<span class="token punctuation">,</span> Uint8List<span class="token operator">></span><span class="token punctuation">(</span>
  entityKey<span class="token punctuation">:</span> <span class="token string">'user_profile_image'</span><span class="token punctuation">,</span>
  getPrimaryKey<span class="token punctuation">:</span> <span class="token punctuation">(</span>t<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> t<span class="token punctuation">.</span>metadata<span class="token punctuation">.</span>userId<span class="token punctuation">,</span>
  getIndices<span class="token punctuation">:</span> <span class="token punctuation">(</span>index<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">index</span><span class="token punctuation">(</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> t<span class="token punctuation">.</span>metadata<span class="token punctuation">.</span>userId<span class="token punctuation">,</span> <span class="token operator">as</span><span class="token punctuation">:</span> <span class="token string">'userId'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">index</span><span class="token punctuation">(</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> t<span class="token punctuation">.</span>metadata<span class="token punctuation">.</span>fetchedAt<span class="token punctuation">,</span> <span class="token operator">as</span><span class="token punctuation">:</span> <span class="token string">'fetchedAt'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  serialize<span class="token punctuation">:</span> <span class="token punctuation">(</span>t<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">final</span> metadataJSON <span class="token operator">=</span> <span class="token function">JsonUtf8Encoder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">convert</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>metadata<span class="token punctuation">.</span><span class="token function">toJSON</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">final</span> lengthHeader <span class="token operator">=</span> Uint8List<span class="token punctuation">.</span><span class="token function">view</span><span class="token punctuation">(</span>
      <span class="token comment">// uint32 is enough for 4GB of metadata</span>
      <span class="token punctuation">(</span><span class="token function">ByteData</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token function">setUint32</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> metadataJSON<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>buffer<span class="token punctuation">,</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token function">BytesBuilder</span><span class="token punctuation">(</span>copy<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">)</span>
          <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>lengthHeader<span class="token punctuation">)</span>
          <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>metadataJSON<span class="token punctuation">)</span>
          <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">takeBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  deserialize<span class="token punctuation">:</span> <span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Get the lenght of the metadata</span>
    <span class="token keyword">final</span> metaDataLength <span class="token operator">=</span> ByteData<span class="token punctuation">.</span><span class="token function">view</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>buffer<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getUint32</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">final</span> jsonDecoder <span class="token operator">=</span> <span class="token keyword">const</span> <span class="token function">Utf8Decoder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fuse</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token function">JsonDecoder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">final</span> metaData <span class="token operator">=</span> ImageMetadata<span class="token punctuation">.</span><span class="token function">fromJSON</span><span class="token punctuation">(</span>
        <span class="token comment">// pass a view into the metadata into the JSON decoder</span>
      jsonDecoder<span class="token punctuation">.</span><span class="token function">convert</span><span class="token punctuation">(</span>Uint8List<span class="token punctuation">.</span><span class="token function">view</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>buffer<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> metaDataLength<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      metadata<span class="token punctuation">:</span> metaData<span class="token punctuation">,</span>
      <span class="token comment">// Pass out the binary data as a read-only view into the raw value retrieved from the database</span>
      data<span class="token punctuation">:</span> Uint8List<span class="token punctuation">.</span><span class="token function">view</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>buffer<span class="token punctuation">,</span> <span class="token number">4</span> <span class="token operator">+</span> metaDataLength<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">asUnmodifiableView</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">ImageMetadata</span> <span class="token punctuation">{</span>
    <span class="token keyword">final</span> int userId<span class="token punctuation">;</span>
    <span class="token keyword">final</span> DateTime fetchedAt<span class="token punctuation">;</span>
    <span class="token keyword">final</span> Uri fetchedFrom<span class="token punctuation">;</span>

    <span class="token comment">// […] implementation of toJSON/fromJSON etc. is omitted for brevity</span>
<span class="token punctuation">}</span>
</code></pre>
<p>With this approach we can just retrieve the profile image with it’s metadata whenever we need it. As we stored the <code>userId</code> and <code>fetchedAt</code> properties as indexed columns, we can also easily query it for</p>
<ul>
<li>no longer known user IDs (in case there was a bug and not all profile images where cleaned up when the user was deleted)</li>
<li>remove stale images (say <code>fetchedAt</code> is older than 7 days)</li>
<li>Check the metadata’s original request URL upon read and re-fetch the image if the server has a new version available</li>
</ul>
<p>A full-fledged example of this approach is available in <a href="https://github.com/LunaONE/indexed_entity_store/blob/f35b55749f3afa1eb4b827ccb26b0e49888581aa/example/lib/src/examples/binary_data_storage.dart">the repository here</a>.</p>
<h2>Next steps</h2>
<p>For the last example it would be super beneficial if we could add a foreign key constraint between the profile image entity and the known users, thus ensuring that the images get cleaned up when a user gets deleted.<br>
This is a further direction to explore in the library, as it seems universally useful, and guarding against this from every possible angle seems cumbersome in the application code (as only the database can reliably enforce such an invariant).</p>
<p>Another abstraction to build on top of foreign key approach could be to combine disk file storage with such an external metadata storage, where insertions and deletions automatically handle the underlying file operations.<br>
This seems much easier to get right on a single file basis for just <code>read</code>/<code>write</code> instead of handling it for various entity types whenever they get updated in the database.</p>
</div></div></div></body></html>